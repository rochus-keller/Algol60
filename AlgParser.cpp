

// This file was automatically generated by Coco/R; don't modify it.
#include "AlgParser.h"
#include "AlgErrors.h"
#include <QtDebug>
#include <QFileInfo>

namespace Alg {


static QString coco_string_create( const wchar_t* str )
{
    return QString::fromStdWString(str);
}

int Parser::peek( quint8 la )
{
	if( la == 0 )
		return d_cur.d_type;
	else if( la == 1 )
		return d_next.d_type;
	else
		return scanner->peekToken( la - 1 ).d_type;
}


void Parser::SynErr(int n, const char* ctx) {
    if (errDist >= minErrDist)
    {
       SynErr(d_next.d_sourcePath,d_next.d_lineNr, d_next.d_colNr, n, errors, ctx);
    }
	errDist = 0;
}

void Parser::SemErr(const char* msg) {
	if (errDist >= minErrDist) errors->error(PARSER_NS::Errors::Semantics,d_cur.d_sourcePath,d_cur.d_lineNr, d_cur.d_colNr, msg);
	errDist = 0;
}

void Parser::Get() {
	for (;;) {
		d_cur = d_next;
		d_next = scanner->nextToken();
        bool deliverToParser = false;
        switch( d_next.d_type )
        {
        case PARSER_NS::Tok_Invalid:
        	if( !d_next.d_val.isEmpty() )
            	SynErr( d_next.d_type, d_next.d_val );
            // else errors already handeled in lexer
            break;
        case PARSER_NS::Tok_Comment:
            d_comments.append(d_next);
            break;
        default:
            deliverToParser = true;
            break;
        }

        if( deliverToParser )
        {
            if( d_next.d_type == PARSER_NS::Tok_Eof )
                d_next.d_type = _EOF;

            la->kind = d_next.d_type;
            if (la->kind <= maxT)
            {
                ++errDist;
                break;
            }
        }

		d_next = d_cur;
	}
}

void Parser::Expect(int n, const char* ctx ) {
	if (la->kind==n) Get(); else { SynErr(n, ctx); }
}

void Parser::ExpectWeak(int n, int follow) {
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
	if (la->kind == n) {Get(); return true;}
	else if (StartOf(repFol)) {return false;}
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

void Parser::program() {
		d_stack.push(&d_root); 
		while (la->kind == _T_unsigned_integer || la->kind == _T_identifier) {
			label();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
		}
		compoundBlock_();
		if (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::label() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_label, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_identifier) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_unsigned_integer) {
			Get();
			addTerminal(); 
		} else SynErr(92,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::compoundBlock_() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_compoundBlock_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_BEGIN,__FUNCTION__);
		addTerminal(); 
		if (StartOf(1)) {
			declaration();
			while (peek(1) == _T_Semi && ( peek(2) == _T_ARRAY || peek(2) == _T_BOOLEAN || peek(2) == _T_INTEGER || peek(2) == _T_OWN || peek(2) == _T_PROCEDURE || peek(2) == _T_REAL || peek(2) == _T_SWITCH ) ) {
				Expect(_T_Semi,__FUNCTION__);
				addTerminal(); 
				declaration();
			}
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		}
		compound_tail();
		d_stack.pop(); 
}

void Parser::declaration() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_SWITCH) {
			switch_declaration();
		} else if (( peek(1) == _T_PROCEDURE || peek(2) == _T_PROCEDURE ) ) {
			procedure_declaration();
		} else if (( peek(1) == _T_ARRAY || peek(2) == _T_ARRAY || peek(3) == _T_ARRAY ) ) {
			array_declaration();
		} else if (StartOf(2)) {
			type_declaration();
		} else SynErr(93,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::compound_tail() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_compound_tail, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		statement();
		while (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
			statement();
		}
		Expect(_T_END,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::statement() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		while (( peek(1) == _T_identifier || peek(1) == _T_unsigned_integer ) && peek(2) == _T_Colon ) {
			label();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
		}
		if (StartOf(3)) {
			unconditional_statement();
		} else if (la->kind == _T_IF) {
			conditional_statement();
		} else if (la->kind == _T_FOR) {
			for_statement();
		} else SynErr(94,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::switch_declaration() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_switch_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_SWITCH,__FUNCTION__);
		addTerminal(); 
		switch_identifier();
		Expect(_T_ColonEq,__FUNCTION__);
		addTerminal(); 
		switch_list();
		d_stack.pop(); 
}

void Parser::procedure_declaration() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_procedure_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_BOOLEAN || la->kind == _T_INTEGER || la->kind == _T_REAL) {
			type();
		}
		Expect(_T_PROCEDURE,__FUNCTION__);
		addTerminal(); 
		procedure_heading();
		procedure_body();
		d_stack.pop(); 
}

void Parser::array_declaration() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_array_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(2)) {
			local_or_own_type();
		}
		Expect(_T_ARRAY,__FUNCTION__);
		addTerminal(); 
		array_list();
		d_stack.pop(); 
}

void Parser::type_declaration() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_type_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		local_or_own_type();
		type_list();
		d_stack.pop(); 
}

void Parser::local_or_own_type() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_local_or_own_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_OWN) {
			Get();
			addTerminal(); 
		}
		type();
		d_stack.pop(); 
}

void Parser::type_list() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_type_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		simple_variable();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			simple_variable();
		}
		d_stack.pop(); 
}

void Parser::type() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_REAL) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_INTEGER) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_BOOLEAN) {
			Get();
			addTerminal(); 
		} else SynErr(95,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::simple_variable() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_simple_variable, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		variable_identifier();
		d_stack.pop(); 
}

void Parser::array_list() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_array_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		array_segment();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			array_segment();
		}
		d_stack.pop(); 
}

void Parser::array_segment() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_array_segment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			Expect(_T_identifier,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_T_Lbrack,__FUNCTION__);
		addTerminal(); 
		bound_pair_list();
		Expect(_T_Rbrack,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::bound_pair_list() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_bound_pair_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		bound_pair();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			bound_pair();
		}
		d_stack.pop(); 
}

void Parser::bound_pair() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_bound_pair, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		lower_bound();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		upper_bound();
		d_stack.pop(); 
}

void Parser::lower_bound() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_lower_bound, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		arithmetic_expression();
		d_stack.pop(); 
}

void Parser::upper_bound() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_upper_bound, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		arithmetic_expression();
		d_stack.pop(); 
}

void Parser::arithmetic_expression() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_arithmetic_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(4)) {
			simple_arithmetic_expression();
		} else if (la->kind == _T_IF) {
			if_clause();
			simple_arithmetic_expression();
			Expect(_T_ELSE,__FUNCTION__);
			addTerminal(); 
			arithmetic_expression();
		} else SynErr(96,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::switch_identifier() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_switch_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::switch_list() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_switch_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		designational_expression();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			designational_expression();
		}
		d_stack.pop(); 
}

void Parser::designational_expression() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_designational_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(5)) {
			simple_designational_expression();
		} else if (la->kind == _T_IF) {
			if_clause();
			simple_designational_expression();
			Expect(_T_ELSE,__FUNCTION__);
			addTerminal(); 
			designational_expression();
		} else SynErr(97,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::procedure_heading() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_procedure_heading, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		procedure_identifier();
		if (la->kind == _T_Lpar) {
			formal_parameter_part();
		}
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_VALUE) {
			value_part();
		}
		if (StartOf(6)) {
			specification_part();
		}
		d_stack.pop(); 
}

void Parser::procedure_body() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_procedure_body, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		statement();
		d_stack.pop(); 
}

void Parser::procedure_identifier() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_procedure_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::formal_parameter_part() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_formal_parameter_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		formal_parameter_list();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::value_part() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_value_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_VALUE,__FUNCTION__);
		addTerminal(); 
		identifier_list();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::specification_part() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_specification_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		while (StartOf(6)) {
			specifier();
			identifier_list();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::formal_parameter_list() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_formal_parameter_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		formal_parameter();
		while (( peek(1) == _T_Comma || peek(1) == _T_Rpar ) && peek(2) == _T_identifier ) {
			parameter_delimiter();
			formal_parameter();
		}
		d_stack.pop(); 
}

void Parser::formal_parameter() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_formal_parameter, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::parameter_delimiter() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_parameter_delimiter, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Rpar) {
			Get();
			addTerminal(); 
			letter_string();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
		} else SynErr(98,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::identifier_list() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_identifier_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			Expect(_T_identifier,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::specifier() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_specifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_STRING) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_LABEL) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_SWITCH) {
			Get();
			addTerminal(); 
		} else if (( peek(1) == _T_PROCEDURE || peek(2) == _T_PROCEDURE || peek(1) == _T_ARRAY || peek(2) == _T_ARRAY ) ) {
			if (la->kind == _T_BOOLEAN || la->kind == _T_INTEGER || la->kind == _T_REAL) {
				type();
			}
			if (la->kind == _T_ARRAY) {
				Get();
				addTerminal(); 
			} else if (la->kind == _T_PROCEDURE) {
				Get();
				addTerminal(); 
			} else SynErr(99,__FUNCTION__);
		} else if (la->kind == _T_BOOLEAN || la->kind == _T_INTEGER || la->kind == _T_REAL) {
			type();
		} else SynErr(100,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::unconditional_statement() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_unconditional_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(7)) {
			basic_statement();
		} else if (la->kind == _T_BEGIN) {
			compoundBlock_();
		} else SynErr(101,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::conditional_statement() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_conditional_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if_clause();
		while (( peek(1) == _T_identifier || peek(1) == _T_unsigned_integer ) && peek(2) == _T_Colon ) {
			label();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
		}
		if (StartOf(8)) {
			unconditional_statement();
			if (la->kind == _T_ELSE) {
				Get();
				addTerminal(); 
				statement();
			}
		} else if (la->kind == _T_FOR) {
			for_statement();
		} else SynErr(102,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::for_statement() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_for_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		for_clause();
		statement();
		d_stack.pop(); 
}

void Parser::basic_statement() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_basic_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		unlabelled_basic_statement();
		d_stack.pop(); 
}

void Parser::unlabelled_basic_statement() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_unlabelled_basic_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_GO || la->kind == _T_GOTO || la->kind == _T_identifier) {
			if (la->kind == _T_identifier) {
				procedureOrAssignmentStmt_();
			} else {
				go_to_statement();
			}
		}
		d_stack.pop(); 
}

void Parser::procedureOrAssignmentStmt_() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_procedureOrAssignmentStmt_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lpar || la->kind == _T_ColonEq || la->kind == _T_Lbrack) {
			if (la->kind == _T_ColonEq || la->kind == _T_Lbrack) {
				if (la->kind == _T_Lbrack) {
					Get();
					addTerminal(); 
					subscript_list();
					Expect(_T_Rbrack,__FUNCTION__);
					addTerminal(); 
				}
				Expect(_T_ColonEq,__FUNCTION__);
				addTerminal(); 
				expression();
				while (la->kind == _T_ColonEq) {
					Get();
					addTerminal(); 
					expression();
				}
			} else {
				Get();
				addTerminal(); 
				actual_parameter_list();
				Expect(_T_Rpar,__FUNCTION__);
				addTerminal(); 
			}
		}
		d_stack.pop(); 
}

void Parser::go_to_statement() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_go_to_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_GOTO) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_GO) {
			Get();
			addTerminal(); 
			Expect(_T_TO,__FUNCTION__);
			addTerminal(); 
		} else SynErr(103,__FUNCTION__);
		designational_expression();
		d_stack.pop(); 
}

void Parser::subscript_list() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_subscript_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		subscript_expression();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			subscript_expression();
		}
		d_stack.pop(); 
}

void Parser::expression() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Boolean_expression();
		d_stack.pop(); 
}

void Parser::actual_parameter_list() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_actual_parameter_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		actual_parameter();
		while (( peek(1) == _T_Comma || peek(1) == _T_Rpar && peek(2) == _T_identifier && peek(3) == _T_Colon ) ) {
			parameter_delimiter();
			actual_parameter();
		}
		d_stack.pop(); 
}

void Parser::actual_parameter() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_actual_parameter, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_string) {
			Get();
			addTerminal(); 
		} else if (StartOf(9)) {
			expression();
		} else SynErr(104,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::letter_string() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_letter_string, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::if_clause() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_if_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_IF,__FUNCTION__);
		addTerminal(); 
		Boolean_expression();
		Expect(_T_THEN,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::Boolean_expression() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_Boolean_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(10)) {
			simple_Boolean();
		} else if (la->kind == _T_IF) {
			if_clause();
			simple_Boolean();
			Expect(_T_ELSE,__FUNCTION__);
			addTerminal(); 
			Boolean_expression();
		} else SynErr(105,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::for_clause() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_for_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_FOR,__FUNCTION__);
		addTerminal(); 
		variable();
		Expect(_T_ColonEq,__FUNCTION__);
		addTerminal(); 
		for_list();
		Expect(_T_DO,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::variable() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_variable, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lbrack) {
			Get();
			addTerminal(); 
			subscript_list();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::for_list() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_for_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		for_list_element();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			for_list_element();
		}
		d_stack.pop(); 
}

void Parser::for_list_element() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_for_list_element, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		arithmetic_expression();
		if (la->kind == _T_STEP || la->kind == _T_WHILE) {
			if (la->kind == _T_STEP) {
				Get();
				addTerminal(); 
				arithmetic_expression();
				Expect(_T_UNTIL,__FUNCTION__);
				addTerminal(); 
				arithmetic_expression();
			} else {
				Get();
				addTerminal(); 
				Boolean_expression();
			}
		}
		d_stack.pop(); 
}

void Parser::simple_arithmetic_expression() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_simple_arithmetic_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Plus || la->kind == _T_Minus) {
			adding_operator();
		}
		term();
		while (la->kind == _T_Plus || la->kind == _T_Minus) {
			adding_operator();
			term();
		}
		d_stack.pop(); 
}

void Parser::adding_operator() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_adding_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Plus) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Minus) {
			Get();
			addTerminal(); 
		} else SynErr(106,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::term() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_term, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		factor();
		while (StartOf(11)) {
			multiplying_operator();
			factor();
		}
		d_stack.pop(); 
}

void Parser::factor() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_factor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		primary();
		while (StartOf(12)) {
			power_sym_();
			primary();
		}
		d_stack.pop(); 
}

void Parser::multiplying_operator() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_multiplying_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Star: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Slash: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Percent: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Udiv: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Umul: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_DIV: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_MOD: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(107,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::primary() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_primary, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_decimal_number || la->kind == _T_unsigned_integer) {
			unsigned_number();
		} else if (la->kind == _T_identifier) {
			variableOrFunction_();
		} else if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			Boolean_expression();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		} else SynErr(108,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::power_sym_() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_power_sym_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_POWER) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Uexp) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Hat) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_2Star) {
			Get();
			addTerminal(); 
		} else SynErr(109,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::unsigned_number() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_unsigned_number, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_unsigned_integer) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_decimal_number) {
			Get();
			addTerminal(); 
		} else SynErr(110,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::variableOrFunction_() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_variableOrFunction_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lpar || la->kind == _T_Lbrack) {
			if (la->kind == _T_Lbrack) {
				Get();
				addTerminal(); 
				subscript_list();
				Expect(_T_Rbrack,__FUNCTION__);
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
				actual_parameter_list();
				Expect(_T_Rpar,__FUNCTION__);
				addTerminal(); 
			}
		}
		d_stack.pop(); 
}

void Parser::simple_designational_expression() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_simple_designational_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		primary();
		d_stack.pop(); 
}

void Parser::simple_Boolean() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_simple_Boolean, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		implication();
		while (la->kind == _T_2Eq || la->kind == _T_Ueq || la->kind == _T_EQUIV) {
			equiv_sym_();
			implication();
		}
		d_stack.pop(); 
}

void Parser::implication() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_implication, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Boolean_term();
		while (la->kind == _T_MinusGt || la->kind == _T_Uimpl || la->kind == _T_IMPL) {
			impl_sym_();
			Boolean_term();
		}
		d_stack.pop(); 
}

void Parser::equiv_sym_() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_equiv_sym_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_EQUIV) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Ueq) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_2Eq) {
			Get();
			addTerminal(); 
		} else SynErr(111,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::Boolean_term() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_Boolean_term, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Boolean_factor();
		while (la->kind == _T_Bar || la->kind == _T_Uor || la->kind == _T_OR) {
			or_sym_();
			Boolean_factor();
		}
		d_stack.pop(); 
}

void Parser::impl_sym_() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_impl_sym_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_IMPL) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Uimpl) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_MinusGt) {
			Get();
			addTerminal(); 
		} else SynErr(112,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::Boolean_factor() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_Boolean_factor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Boolean_secondary();
		while (la->kind == _T_Amp || la->kind == _T_Uand || la->kind == _T_AND) {
			and_sym_();
			Boolean_secondary();
		}
		d_stack.pop(); 
}

void Parser::or_sym_() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_or_sym_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_OR) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Uor) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Bar) {
			Get();
			addTerminal(); 
		} else SynErr(113,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::Boolean_secondary() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_Boolean_secondary, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(13)) {
			Boolean_primary();
		} else if (la->kind == _T_Bang || la->kind == _T_Unot || la->kind == _T_NOT) {
			not_sym_();
			Boolean_primary();
		} else SynErr(114,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::and_sym_() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_and_sym_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_AND) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Uand) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Amp) {
			Get();
			addTerminal(); 
		} else SynErr(115,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::Boolean_primary() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_Boolean_primary, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_FALSE || la->kind == _T_TRUE) {
			logical_value();
		} else if (StartOf(4)) {
			relation();
		} else SynErr(116,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::not_sym_() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_not_sym_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_NOT) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Unot) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Bang) {
			Get();
			addTerminal(); 
		} else SynErr(117,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::logical_value() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_logical_value, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_TRUE) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_FALSE) {
			Get();
			addTerminal(); 
		} else SynErr(118,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::relation() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_relation, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		simple_arithmetic_expression();
		if (StartOf(14)) {
			relational_operator();
			simple_arithmetic_expression();
		}
		d_stack.pop(); 
}

void Parser::relational_operator() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_relational_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Lt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Leq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Geq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Gt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_LtGt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Uleq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Ugeq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Uneq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_BangEq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_HatEq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_LESS: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_NOTGREATER: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_EQUAL: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_NOTLESS: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_GREATER: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_NOTEQUAL: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(119,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::variable_identifier() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_variable_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::subscript_expression() {
		Alg::SynTree* n = new Alg::SynTree( Alg::SynTree::R_subscript_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		arithmetic_expression();
		d_stack.pop(); 
}




// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer {
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType {
		char dummy1;
	};
	
	struct InitExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer {
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType {
		char dummy1;
	};
	
	struct DestroyExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller {
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> {
	static void CallInit(T *t) {
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller {
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> {
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};

void Parser::Parse() {
	d_cur = PARSER_NS::Token();
	d_next = PARSER_NS::Token();
	Get();
	program();
	Expect(0,__FUNCTION__);
}

Parser::Parser(PARSER_NS::Lexer *scanner, PARSER_NS::Errors* err) {
	maxT = 91;

	ParserInitCaller<Parser>::CallInit(this);
	la = &d_dummy;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
	errors = err;
}

bool Parser::StartOf(int s) {
	const bool T = true;
	const bool x = false;

	static bool set[15][93] = {
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,T,x,T, T,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x},
		{x,x,x,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,T,x, x,x,x,x, x},
		{x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,T,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,T, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,T,T,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x},
		{x,x,T,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,T, T,x,T,x, x,x,x,x, x},
		{x,x,T,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,T, T,x,T,x, x,x,x,x, x},
		{x,x,x,x, T,x,x,x, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,T, T,x,T,x, x,x,x,x, x},
		{x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,x,T, T,x,x,x, T,x,x,x, x,x,x,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,T,x,x, x,x,T,x, x,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x}
	};



	return set[s][la->kind];
}

Parser::~Parser() {
	ParserDestroyCaller<Parser>::CallDestroy(this);
}

void Parser::SynErr(const QString& sourcePath, int line, int col, int n, PARSER_NS::Errors* err, const char* ctx, const QString& str ) {
	QString s;
	QString ctxStr;
	if( ctx )
		ctxStr = QString( " in %1" ).arg(ctx);
    if( n == 0 )
        s = QString("EOF expected%1").arg(ctxStr);
    else if( n < PARSER_NS::TT_Specials )
        s = QString("'%2' expected%1").arg(ctxStr).arg(PARSER_NS::tokenTypeString(n));
    else if( n <= PARSER_NS::TT_Max )
        s = QString("%2 expected%1").arg(ctxStr).arg(PARSER_NS::tokenTypeString(n));
    else
	switch (n) {
			case 0: s = coco_string_create(L"EOF expected"); break;
			case 1: s = coco_string_create(L"T_Literals_ expected"); break;
			case 2: s = coco_string_create(L"T_Bang expected"); break;
			case 3: s = coco_string_create(L"T_BangEq expected"); break;
			case 4: s = coco_string_create(L"T_Percent expected"); break;
			case 5: s = coco_string_create(L"T_Amp expected"); break;
			case 6: s = coco_string_create(L"T_Lpar expected"); break;
			case 7: s = coco_string_create(L"T_Rpar expected"); break;
			case 8: s = coco_string_create(L"T_Star expected"); break;
			case 9: s = coco_string_create(L"T_2Star expected"); break;
			case 10: s = coco_string_create(L"T_Plus expected"); break;
			case 11: s = coco_string_create(L"T_Comma expected"); break;
			case 12: s = coco_string_create(L"T_Minus expected"); break;
			case 13: s = coco_string_create(L"T_MinusGt expected"); break;
			case 14: s = coco_string_create(L"T_Slash expected"); break;
			case 15: s = coco_string_create(L"T_Colon expected"); break;
			case 16: s = coco_string_create(L"T_ColonEq expected"); break;
			case 17: s = coco_string_create(L"T_Semi expected"); break;
			case 18: s = coco_string_create(L"T_Lt expected"); break;
			case 19: s = coco_string_create(L"T_Leq expected"); break;
			case 20: s = coco_string_create(L"T_LtGt expected"); break;
			case 21: s = coco_string_create(L"T_Eq expected"); break;
			case 22: s = coco_string_create(L"T_2Eq expected"); break;
			case 23: s = coco_string_create(L"T_Gt expected"); break;
			case 24: s = coco_string_create(L"T_Geq expected"); break;
			case 25: s = coco_string_create(L"T_Lbrack expected"); break;
			case 26: s = coco_string_create(L"T_Rbrack expected"); break;
			case 27: s = coco_string_create(L"T_Hat expected"); break;
			case 28: s = coco_string_create(L"T_HatEq expected"); break;
			case 29: s = coco_string_create(L"T_Bar expected"); break;
			case 30: s = coco_string_create(L"T_Unot expected"); break;
			case 31: s = coco_string_create(L"T_Umul expected"); break;
			case 32: s = coco_string_create(L"T_Udiv expected"); break;
			case 33: s = coco_string_create(L"T_Uexp expected"); break;
			case 34: s = coco_string_create(L"T_Uand expected"); break;
			case 35: s = coco_string_create(L"T_Uor expected"); break;
			case 36: s = coco_string_create(L"T_Uneq expected"); break;
			case 37: s = coco_string_create(L"T_Ueq expected"); break;
			case 38: s = coco_string_create(L"T_Uleq expected"); break;
			case 39: s = coco_string_create(L"T_Ugeq expected"); break;
			case 40: s = coco_string_create(L"T_Uimpl expected"); break;
			case 41: s = coco_string_create(L"T_Keywords_ expected"); break;
			case 42: s = coco_string_create(L"T_AND expected"); break;
			case 43: s = coco_string_create(L"T_ARRAY expected"); break;
			case 44: s = coco_string_create(L"T_BEGIN expected"); break;
			case 45: s = coco_string_create(L"T_BOOLEAN expected"); break;
			case 46: s = coco_string_create(L"T_COMMENT expected"); break;
			case 47: s = coco_string_create(L"T_DIV expected"); break;
			case 48: s = coco_string_create(L"T_DO expected"); break;
			case 49: s = coco_string_create(L"T_ELSE expected"); break;
			case 50: s = coco_string_create(L"T_END expected"); break;
			case 51: s = coco_string_create(L"T_EQUAL expected"); break;
			case 52: s = coco_string_create(L"T_EQUIV expected"); break;
			case 53: s = coco_string_create(L"T_FALSE expected"); break;
			case 54: s = coco_string_create(L"T_FOR expected"); break;
			case 55: s = coco_string_create(L"T_GO expected"); break;
			case 56: s = coco_string_create(L"T_GOTO expected"); break;
			case 57: s = coco_string_create(L"T_GREATER expected"); break;
			case 58: s = coco_string_create(L"T_IF expected"); break;
			case 59: s = coco_string_create(L"T_IMPL expected"); break;
			case 60: s = coco_string_create(L"T_INTEGER expected"); break;
			case 61: s = coco_string_create(L"T_LABEL expected"); break;
			case 62: s = coco_string_create(L"T_LESS expected"); break;
			case 63: s = coco_string_create(L"T_MOD expected"); break;
			case 64: s = coco_string_create(L"T_NOT expected"); break;
			case 65: s = coco_string_create(L"T_NOTEQUAL expected"); break;
			case 66: s = coco_string_create(L"T_NOTGREATER expected"); break;
			case 67: s = coco_string_create(L"T_NOTLESS expected"); break;
			case 68: s = coco_string_create(L"T_OR expected"); break;
			case 69: s = coco_string_create(L"T_OWN expected"); break;
			case 70: s = coco_string_create(L"T_POWER expected"); break;
			case 71: s = coco_string_create(L"T_PROCEDURE expected"); break;
			case 72: s = coco_string_create(L"T_REAL expected"); break;
			case 73: s = coco_string_create(L"T_STEP expected"); break;
			case 74: s = coco_string_create(L"T_STRING expected"); break;
			case 75: s = coco_string_create(L"T_SWITCH expected"); break;
			case 76: s = coco_string_create(L"T_THEN expected"); break;
			case 77: s = coco_string_create(L"T_TO expected"); break;
			case 78: s = coco_string_create(L"T_TRUE expected"); break;
			case 79: s = coco_string_create(L"T_UNTIL expected"); break;
			case 80: s = coco_string_create(L"T_VALUE expected"); break;
			case 81: s = coco_string_create(L"T_WHILE expected"); break;
			case 82: s = coco_string_create(L"T_Specials_ expected"); break;
			case 83: s = coco_string_create(L"T_decimal_number expected"); break;
			case 84: s = coco_string_create(L"T_unsigned_integer expected"); break;
			case 85: s = coco_string_create(L"T_string expected"); break;
			case 86: s = coco_string_create(L"T_identifier expected"); break;
			case 87: s = coco_string_create(L"T_basic_symbol expected"); break;
			case 88: s = coco_string_create(L"T_Comment expected"); break;
			case 89: s = coco_string_create(L"T_Eof expected"); break;
			case 90: s = coco_string_create(L"T_MaxToken_ expected"); break;
			case 91: s = coco_string_create(L"??? expected"); break;
			case 92: s = coco_string_create(L"invalid label"); break;
			case 93: s = coco_string_create(L"invalid declaration"); break;
			case 94: s = coco_string_create(L"invalid statement"); break;
			case 95: s = coco_string_create(L"invalid type"); break;
			case 96: s = coco_string_create(L"invalid arithmetic_expression"); break;
			case 97: s = coco_string_create(L"invalid designational_expression"); break;
			case 98: s = coco_string_create(L"invalid parameter_delimiter"); break;
			case 99: s = coco_string_create(L"invalid specifier"); break;
			case 100: s = coco_string_create(L"invalid specifier"); break;
			case 101: s = coco_string_create(L"invalid unconditional_statement"); break;
			case 102: s = coco_string_create(L"invalid conditional_statement"); break;
			case 103: s = coco_string_create(L"invalid go_to_statement"); break;
			case 104: s = coco_string_create(L"invalid actual_parameter"); break;
			case 105: s = coco_string_create(L"invalid Boolean_expression"); break;
			case 106: s = coco_string_create(L"invalid adding_operator"); break;
			case 107: s = coco_string_create(L"invalid multiplying_operator"); break;
			case 108: s = coco_string_create(L"invalid primary"); break;
			case 109: s = coco_string_create(L"invalid power_sym_"); break;
			case 110: s = coco_string_create(L"invalid unsigned_number"); break;
			case 111: s = coco_string_create(L"invalid equiv_sym_"); break;
			case 112: s = coco_string_create(L"invalid impl_sym_"); break;
			case 113: s = coco_string_create(L"invalid or_sym_"); break;
			case 114: s = coco_string_create(L"invalid Boolean_secondary"); break;
			case 115: s = coco_string_create(L"invalid and_sym_"); break;
			case 116: s = coco_string_create(L"invalid Boolean_primary"); break;
			case 117: s = coco_string_create(L"invalid not_sym_"); break;
			case 118: s = coco_string_create(L"invalid logical_value"); break;
			case 119: s = coco_string_create(L"invalid relational_operator"); break;

		default:
		{
			s = QString( "generic error %1").arg(n);
		}
		break;
	}
    if( !str.isEmpty() )
        s = QString("%1 %2").arg(s).arg(str);
	if( err )
		err->error(PARSER_NS::Errors::Syntax, sourcePath, line, col, s);
	else
		qCritical() << "Error Parser" << line << col << s;
	//count++;
}

} // namespace

