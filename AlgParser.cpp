// This file was automatically generated by EbnfStudio; don't modify it!
#include "AlgParser.h"
using namespace Alg;

static inline bool FIRST_program(int tt) {
	return tt == Tok_BEGIN || tt == Tok_unsigned_integer || tt == Tok_identifier;
}

static inline bool FIRST_compoundBlock_(int tt) {
	return tt == Tok_BEGIN;
}

static inline bool FIRST_compound_tail(int tt) {
	switch(tt){
	case Tok_BEGIN:
	case Tok_FOR:
	case Tok_unsigned_integer:
	case Tok_GOTO:
	case Tok_IF:
	case Tok_identifier:
	case Tok_GO:
	case Tok_END:
	case Tok_Semi:
		return true;
	default: return false;
	}
}

static inline bool FIRST_declaration(int tt) {
	switch(tt){
	case Tok_ARRAY:
	case Tok_BOOLEAN:
	case Tok_PROCEDURE:
	case Tok_REAL:
	case Tok_INTEGER:
	case Tok_OWN:
	case Tok_SWITCH:
		return true;
	default: return false;
	}
}

static inline bool FIRST_type_declaration(int tt) {
	return tt == Tok_BOOLEAN || tt == Tok_REAL || tt == Tok_INTEGER || tt == Tok_OWN;
}

static inline bool FIRST_local_or_own_type(int tt) {
	return tt == Tok_BOOLEAN || tt == Tok_REAL || tt == Tok_INTEGER || tt == Tok_OWN;
}

static inline bool FIRST_type(int tt) {
	return tt == Tok_BOOLEAN || tt == Tok_REAL || tt == Tok_INTEGER;
}

static inline bool FIRST_type_list(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_array_declaration(int tt) {
	return tt == Tok_ARRAY || tt == Tok_BOOLEAN || tt == Tok_REAL || tt == Tok_INTEGER || tt == Tok_OWN;
}

static inline bool FIRST_array_list(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_array_segment(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_bound_pair_list(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_IF:
	case Tok_identifier:
	case Tok_Minus:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_bound_pair(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_IF:
	case Tok_identifier:
	case Tok_Minus:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_upper_bound(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_IF:
	case Tok_identifier:
	case Tok_Minus:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_lower_bound(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_IF:
	case Tok_identifier:
	case Tok_Minus:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_switch_declaration(int tt) {
	return tt == Tok_SWITCH;
}

static inline bool FIRST_switch_identifier(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_switch_list(int tt) {
	return tt == Tok_Lpar || tt == Tok_unsigned_integer || tt == Tok_IF || tt == Tok_identifier || tt == Tok_decimal_number;
}

static inline bool FIRST_procedure_declaration(int tt) {
	return tt == Tok_BOOLEAN || tt == Tok_PROCEDURE || tt == Tok_REAL || tt == Tok_INTEGER;
}

static inline bool FIRST_procedure_heading(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_procedure_identifier(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_formal_parameter_part(int tt) {
	return tt == Tok_Lpar;
}

static inline bool FIRST_formal_parameter_list(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_formal_parameter(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_value_part(int tt) {
	return tt == Tok_VALUE;
}

static inline bool FIRST_specification_part(int tt) {
	switch(tt){
	case Tok_LABEL:
	case Tok_ARRAY:
	case Tok_BOOLEAN:
	case Tok_PROCEDURE:
	case Tok_REAL:
	case Tok_INTEGER:
	case Tok_STRING:
	case Tok_SWITCH:
		return true;
	default: return false;
	}
}

static inline bool FIRST_specifier(int tt) {
	switch(tt){
	case Tok_LABEL:
	case Tok_ARRAY:
	case Tok_BOOLEAN:
	case Tok_PROCEDURE:
	case Tok_REAL:
	case Tok_INTEGER:
	case Tok_STRING:
	case Tok_SWITCH:
		return true;
	default: return false;
	}
}

static inline bool FIRST_identifier_list(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_procedure_body(int tt) {
	switch(tt){
	case Tok_BEGIN:
	case Tok_FOR:
	case Tok_unsigned_integer:
	case Tok_GOTO:
	case Tok_IF:
	case Tok_identifier:
	case Tok_GO:
		return true;
	default: return false;
	}
}

static inline bool FIRST_statement(int tt) {
	switch(tt){
	case Tok_BEGIN:
	case Tok_FOR:
	case Tok_unsigned_integer:
	case Tok_GOTO:
	case Tok_IF:
	case Tok_identifier:
	case Tok_GO:
		return true;
	default: return false;
	}
}

static inline bool FIRST_unconditional_statement(int tt) {
	return tt == Tok_BEGIN || tt == Tok_GOTO || tt == Tok_identifier || tt == Tok_GO;
}

static inline bool FIRST_basic_statement(int tt) {
	return tt == Tok_GOTO || tt == Tok_identifier || tt == Tok_GO;
}

static inline bool FIRST_label(int tt) {
	return tt == Tok_unsigned_integer || tt == Tok_identifier;
}

static inline bool FIRST_unlabelled_basic_statement(int tt) {
	return tt == Tok_GOTO || tt == Tok_identifier || tt == Tok_GO;
}

static inline bool FIRST_procedureOrAssignmentStmt_(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_go_to_statement(int tt) {
	return tt == Tok_GOTO || tt == Tok_GO;
}

static inline bool FIRST_actual_parameter_list(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_string:
	case Tok_IF:
	case Tok_Unot:
	case Tok_identifier:
	case Tok_Bang:
	case Tok_NOT:
	case Tok_FALSE:
	case Tok_Minus:
	case Tok_TRUE:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_parameter_delimiter(int tt) {
	return tt == Tok_Rpar || tt == Tok_Comma;
}

static inline bool FIRST_actual_parameter(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_string:
	case Tok_IF:
	case Tok_Unot:
	case Tok_identifier:
	case Tok_Bang:
	case Tok_NOT:
	case Tok_FALSE:
	case Tok_Minus:
	case Tok_TRUE:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_conditional_statement(int tt) {
	return tt == Tok_IF;
}

static inline bool FIRST_if_clause(int tt) {
	return tt == Tok_IF;
}

static inline bool FIRST_for_statement(int tt) {
	return tt == Tok_FOR;
}

static inline bool FIRST_for_clause(int tt) {
	return tt == Tok_FOR;
}

static inline bool FIRST_for_list(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_IF:
	case Tok_identifier:
	case Tok_Minus:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_for_list_element(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_IF:
	case Tok_identifier:
	case Tok_Minus:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_expression(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_IF:
	case Tok_Unot:
	case Tok_identifier:
	case Tok_Bang:
	case Tok_NOT:
	case Tok_FALSE:
	case Tok_Minus:
	case Tok_TRUE:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_arithmetic_expression(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_IF:
	case Tok_identifier:
	case Tok_Minus:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_simple_arithmetic_expression(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_identifier:
	case Tok_Minus:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_adding_operator(int tt) {
	return tt == Tok_Plus || tt == Tok_Minus;
}

static inline bool FIRST_term(int tt) {
	return tt == Tok_Lpar || tt == Tok_unsigned_integer || tt == Tok_identifier || tt == Tok_decimal_number;
}

static inline bool FIRST_multiplying_operator(int tt) {
	switch(tt){
	case Tok_Star:
	case Tok_MOD:
	case Tok_Udiv:
	case Tok_Umul:
	case Tok_Percent:
	case Tok_DIV:
	case Tok_Slash:
		return true;
	default: return false;
	}
}

static inline bool FIRST_factor(int tt) {
	return tt == Tok_Lpar || tt == Tok_unsigned_integer || tt == Tok_identifier || tt == Tok_decimal_number;
}

static inline bool FIRST_power_sym_(int tt) {
	return tt == Tok_Uexp || tt == Tok_POWER || tt == Tok_2Star || tt == Tok_Hat;
}

static inline bool FIRST_primary(int tt) {
	return tt == Tok_Lpar || tt == Tok_unsigned_integer || tt == Tok_identifier || tt == Tok_decimal_number;
}

static inline bool FIRST_designational_expression(int tt) {
	return tt == Tok_Lpar || tt == Tok_unsigned_integer || tt == Tok_IF || tt == Tok_identifier || tt == Tok_decimal_number;
}

static inline bool FIRST_simple_designational_expression(int tt) {
	return tt == Tok_Lpar || tt == Tok_unsigned_integer || tt == Tok_identifier || tt == Tok_decimal_number;
}

static inline bool FIRST_Boolean_expression(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_IF:
	case Tok_Unot:
	case Tok_identifier:
	case Tok_Bang:
	case Tok_NOT:
	case Tok_FALSE:
	case Tok_Minus:
	case Tok_TRUE:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_simple_Boolean(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_Unot:
	case Tok_identifier:
	case Tok_Bang:
	case Tok_NOT:
	case Tok_FALSE:
	case Tok_Minus:
	case Tok_TRUE:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_equiv_sym_(int tt) {
	return tt == Tok_2Eq || tt == Tok_Ueq || tt == Tok_EQUIV;
}

static inline bool FIRST_implication(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_Unot:
	case Tok_identifier:
	case Tok_Bang:
	case Tok_NOT:
	case Tok_FALSE:
	case Tok_Minus:
	case Tok_TRUE:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_impl_sym_(int tt) {
	return tt == Tok_Uimpl || tt == Tok_IMPL || tt == Tok_MinusGt;
}

static inline bool FIRST_Boolean_term(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_Unot:
	case Tok_identifier:
	case Tok_Bang:
	case Tok_NOT:
	case Tok_FALSE:
	case Tok_Minus:
	case Tok_TRUE:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_or_sym_(int tt) {
	return tt == Tok_Bar || tt == Tok_OR || tt == Tok_Uor;
}

static inline bool FIRST_Boolean_factor(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_Unot:
	case Tok_identifier:
	case Tok_Bang:
	case Tok_NOT:
	case Tok_FALSE:
	case Tok_Minus:
	case Tok_TRUE:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_and_sym_(int tt) {
	return tt == Tok_Amp || tt == Tok_Uand || tt == Tok_AND;
}

static inline bool FIRST_Boolean_secondary(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_Unot:
	case Tok_identifier:
	case Tok_Bang:
	case Tok_NOT:
	case Tok_FALSE:
	case Tok_Minus:
	case Tok_TRUE:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_not_sym_(int tt) {
	return tt == Tok_Unot || tt == Tok_Bang || tt == Tok_NOT;
}

static inline bool FIRST_Boolean_primary(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_identifier:
	case Tok_FALSE:
	case Tok_Minus:
	case Tok_TRUE:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_relation(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_identifier:
	case Tok_Minus:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_relational_operator(int tt) {
	switch(tt){
	case Tok_Uleq:
	case Tok_Lt:
	case Tok_NOTGREATER:
	case Tok_EQUAL:
	case Tok_LESS:
	case Tok_Geq:
	case Tok_Gt:
	case Tok_LtGt:
	case Tok_BangEq:
	case Tok_Eq:
	case Tok_HatEq:
	case Tok_Uneq:
	case Tok_NOTLESS:
	case Tok_Leq:
	case Tok_Ugeq:
	case Tok_NOTEQUAL:
	case Tok_GREATER:
		return true;
	default: return false;
	}
}

static inline bool FIRST_variableOrFunction_(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_variable(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_simple_variable(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_variable_identifier(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_subscript_list(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_IF:
	case Tok_identifier:
	case Tok_Minus:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_subscript_expression(int tt) {
	switch(tt){
	case Tok_Lpar:
	case Tok_Plus:
	case Tok_unsigned_integer:
	case Tok_IF:
	case Tok_identifier:
	case Tok_Minus:
	case Tok_decimal_number:
		return true;
	default: return false;
	}
}

static inline bool FIRST_unsigned_number(int tt) {
	return tt == Tok_unsigned_integer || tt == Tok_decimal_number;
}

static inline bool FIRST_letter_string(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_logical_value(int tt) {
	return tt == Tok_FALSE || tt == Tok_TRUE;
}

void Parser::RunParser() {
	root = SynTree();
	errors.clear();
	next();
	program(&root);
}

void Parser::next() {
	cur = la;
	la = scanner->next();
	while( la.d_type == Tok_Invalid ) {
		errors << Error(la.d_val, la.d_lineNr, la.d_colNr, la.d_sourcePath);
		la = scanner->next();
	}
}

Token Parser::peek(int off) {
	if( off == 1 )
		return la;
	else if( off == 0 )
		return cur;
	else
		return scanner->peek(off-1);
}

void Parser::invalid(const char* what) {
	errors << Error(QString("invalid %1").arg(what),la.d_lineNr, la.d_colNr, la.d_sourcePath);
}

bool Parser::expect(int tt, bool pkw, const char* where) {
	if( la.d_type == tt || la.d_code == tt) { next(); return true; }
	else { errors << Error(QString("'%1' expected in %2").arg(tokenTypeString(tt)).arg(where),la.d_lineNr, la.d_colNr, la.d_sourcePath); return false; }
}

static inline void dummy() {}
	void Parser::addTerminal(SynTree* st) {
		SynTree* tmp = new SynTree( cur ); st->d_children.append(tmp);
	}
void Parser::program(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_program, la); st->d_children.append(tmp); st = tmp; }
	while( FIRST_label(la.d_type) ) {
		label(st);
		if( expect(Tok_Colon, false, "program") ) addTerminal(st);
	}
	compoundBlock_(st);
	if( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "program") ) addTerminal(st);
	}
}

void Parser::compoundBlock_(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_compoundBlock_, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_BEGIN, false, "compoundBlock_") ) addTerminal(st);
	if( FIRST_declaration(la.d_type) ) {
		declaration(st);
		while( ( peek(1).d_type == Tok_Semi && ( peek(2).d_type == Tok_ARRAY || peek(2).d_type == Tok_BOOLEAN || peek(2).d_type == Tok_INTEGER || peek(2).d_type == Tok_OWN || peek(2).d_type == Tok_PROCEDURE || peek(2).d_type == Tok_REAL || peek(2).d_type == Tok_SWITCH ) )  ) {
			if( expect(Tok_Semi, false, "compoundBlock_") ) addTerminal(st);
			declaration(st);
		}
		if( expect(Tok_Semi, false, "compoundBlock_") ) addTerminal(st);
	}
	compound_tail(st);
}

void Parser::compound_tail(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_compound_tail, la); st->d_children.append(tmp); st = tmp; }
	statement(st);
	while( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "compound_tail") ) addTerminal(st);
		statement(st);
	}
	if( expect(Tok_END, false, "compound_tail") ) addTerminal(st);
}

void Parser::declaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_declaration, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_switch_declaration(la.d_type) ) {
		switch_declaration(st);
	} else if( ( ( peek(1).d_type == Tok_PROCEDURE || peek(2).d_type == Tok_PROCEDURE ) )  ) {
		procedure_declaration(st);
	} else if( ( ( peek(1).d_type == Tok_ARRAY || peek(2).d_type == Tok_ARRAY || peek(3).d_type == Tok_ARRAY ) )  ) {
		array_declaration(st);
	} else if( FIRST_type_declaration(la.d_type) ) {
		type_declaration(st);
	} else
		invalid("declaration");
}

void Parser::type_declaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_type_declaration, la); st->d_children.append(tmp); st = tmp; }
	local_or_own_type(st);
	type_list(st);
}

void Parser::local_or_own_type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_local_or_own_type, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_OWN ) {
		if( expect(Tok_OWN, false, "local_or_own_type") ) addTerminal(st);
	}
	type(st);
}

void Parser::type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_type, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_REAL ) {
		if( expect(Tok_REAL, false, "type") ) addTerminal(st);
	} else if( la.d_type == Tok_INTEGER ) {
		if( expect(Tok_INTEGER, false, "type") ) addTerminal(st);
	} else if( la.d_type == Tok_BOOLEAN ) {
		if( expect(Tok_BOOLEAN, false, "type") ) addTerminal(st);
	} else
		invalid("type");
}

void Parser::type_list(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_type_list, la); st->d_children.append(tmp); st = tmp; }
	simple_variable(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "type_list") ) addTerminal(st);
		simple_variable(st);
	}
}

void Parser::array_declaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_array_declaration, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_local_or_own_type(la.d_type) ) {
		local_or_own_type(st);
	}
	if( expect(Tok_ARRAY, false, "array_declaration") ) addTerminal(st);
	array_list(st);
}

void Parser::array_list(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_array_list, la); st->d_children.append(tmp); st = tmp; }
	array_segment(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "array_list") ) addTerminal(st);
		array_segment(st);
	}
}

void Parser::array_segment(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_array_segment, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "array_segment") ) addTerminal(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "array_segment") ) addTerminal(st);
		if( expect(Tok_identifier, false, "array_segment") ) addTerminal(st);
	}
	if( expect(Tok_Lbrack, false, "array_segment") ) addTerminal(st);
	bound_pair_list(st);
	if( expect(Tok_Rbrack, false, "array_segment") ) addTerminal(st);
}

void Parser::bound_pair_list(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_bound_pair_list, la); st->d_children.append(tmp); st = tmp; }
	bound_pair(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "bound_pair_list") ) addTerminal(st);
		bound_pair(st);
	}
}

void Parser::bound_pair(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_bound_pair, la); st->d_children.append(tmp); st = tmp; }
	lower_bound(st);
	if( expect(Tok_Colon, false, "bound_pair") ) addTerminal(st);
	upper_bound(st);
}

void Parser::upper_bound(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_upper_bound, la); st->d_children.append(tmp); st = tmp; }
	arithmetic_expression(st);
}

void Parser::lower_bound(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_lower_bound, la); st->d_children.append(tmp); st = tmp; }
	arithmetic_expression(st);
}

void Parser::switch_declaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_switch_declaration, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_SWITCH, false, "switch_declaration") ) addTerminal(st);
	switch_identifier(st);
	if( expect(Tok_ColonEq, false, "switch_declaration") ) addTerminal(st);
	switch_list(st);
}

void Parser::switch_identifier(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_switch_identifier, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "switch_identifier") ) addTerminal(st);
}

void Parser::switch_list(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_switch_list, la); st->d_children.append(tmp); st = tmp; }
	designational_expression(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "switch_list") ) addTerminal(st);
		designational_expression(st);
	}
}

void Parser::procedure_declaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_procedure_declaration, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_type(la.d_type) ) {
		type(st);
	}
	if( expect(Tok_PROCEDURE, false, "procedure_declaration") ) addTerminal(st);
	procedure_heading(st);
	procedure_body(st);
}

void Parser::procedure_heading(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_procedure_heading, la); st->d_children.append(tmp); st = tmp; }
	procedure_identifier(st);
	if( FIRST_formal_parameter_part(la.d_type) ) {
		formal_parameter_part(st);
	}
	if( expect(Tok_Semi, false, "procedure_heading") ) addTerminal(st);
	if( FIRST_value_part(la.d_type) ) {
		value_part(st);
	}
	if( FIRST_specification_part(la.d_type) ) {
		specification_part(st);
	}
}

void Parser::procedure_identifier(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_procedure_identifier, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "procedure_identifier") ) addTerminal(st);
}

void Parser::formal_parameter_part(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_formal_parameter_part, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lpar, false, "formal_parameter_part") ) addTerminal(st);
	formal_parameter_list(st);
	if( expect(Tok_Rpar, false, "formal_parameter_part") ) addTerminal(st);
}

void Parser::formal_parameter_list(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_formal_parameter_list, la); st->d_children.append(tmp); st = tmp; }
	formal_parameter(st);
	while( ( ( peek(1).d_type == Tok_Comma || peek(1).d_type == Tok_Rpar ) && peek(2).d_type == Tok_identifier )  ) {
		parameter_delimiter(st);
		formal_parameter(st);
	}
}

void Parser::formal_parameter(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_formal_parameter, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "formal_parameter") ) addTerminal(st);
}

void Parser::value_part(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_value_part, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_VALUE, false, "value_part") ) addTerminal(st);
	identifier_list(st);
	if( expect(Tok_Semi, false, "value_part") ) addTerminal(st);
}

void Parser::specification_part(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_specification_part, la); st->d_children.append(tmp); st = tmp; }
	while( FIRST_specifier(la.d_type) ) {
		specifier(st);
		identifier_list(st);
		if( expect(Tok_Semi, false, "specification_part") ) addTerminal(st);
	}
}

void Parser::specifier(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_specifier, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_STRING ) {
		if( expect(Tok_STRING, false, "specifier") ) addTerminal(st);
	} else if( la.d_type == Tok_LABEL ) {
		if( expect(Tok_LABEL, false, "specifier") ) addTerminal(st);
	} else if( la.d_type == Tok_SWITCH ) {
		if( expect(Tok_SWITCH, false, "specifier") ) addTerminal(st);
	} else if( ( ( peek(1).d_type == Tok_PROCEDURE || peek(2).d_type == Tok_PROCEDURE || peek(1).d_type == Tok_ARRAY || peek(2).d_type == Tok_ARRAY ) )  ) {
		if( FIRST_type(la.d_type) ) {
			type(st);
		}
		if( la.d_type == Tok_ARRAY ) {
			if( expect(Tok_ARRAY, false, "specifier") ) addTerminal(st);
		} else if( la.d_type == Tok_PROCEDURE ) {
			if( expect(Tok_PROCEDURE, false, "specifier") ) addTerminal(st);
		} else
			invalid("specifier");
	} else if( FIRST_type(la.d_type) ) {
		type(st);
	} else
		invalid("specifier");
}

void Parser::identifier_list(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_identifier_list, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "identifier_list") ) addTerminal(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "identifier_list") ) addTerminal(st);
		if( expect(Tok_identifier, false, "identifier_list") ) addTerminal(st);
	}
}

void Parser::procedure_body(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_procedure_body, la); st->d_children.append(tmp); st = tmp; }
	statement(st);
}

void Parser::statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_statement, la); st->d_children.append(tmp); st = tmp; }
	while( ( ( peek(1).d_type == Tok_identifier || peek(1).d_type == Tok_unsigned_integer ) && peek(2).d_type == Tok_Colon )  ) {
		label(st);
		if( expect(Tok_Colon, false, "statement") ) addTerminal(st);
	}
	if( FIRST_unconditional_statement(la.d_type) || la.d_type == Tok_Semi || la.d_type == Tok_ELSE || la.d_type == Tok_Semi || la.d_type == Tok_Semi || la.d_type == Tok_END ) {
		unconditional_statement(st);
	} else if( FIRST_conditional_statement(la.d_type) ) {
		conditional_statement(st);
	} else if( FIRST_for_statement(la.d_type) ) {
		for_statement(st);
	} else
		invalid("statement");
}

void Parser::unconditional_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_unconditional_statement, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_basic_statement(la.d_type) || la.d_type == Tok_Semi || la.d_type == Tok_ELSE || la.d_type == Tok_Semi || la.d_type == Tok_Semi || la.d_type == Tok_END ) {
		basic_statement(st);
	} else if( FIRST_compoundBlock_(la.d_type) ) {
		compoundBlock_(st);
	} else
		invalid("unconditional_statement");
}

void Parser::basic_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_basic_statement, la); st->d_children.append(tmp); st = tmp; }
	unlabelled_basic_statement(st);
}

void Parser::label(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_label, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_identifier ) {
		if( expect(Tok_identifier, false, "label") ) addTerminal(st);
	} else if( la.d_type == Tok_unsigned_integer ) {
		if( expect(Tok_unsigned_integer, false, "label") ) addTerminal(st);
	} else
		invalid("label");
}

void Parser::unlabelled_basic_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_unlabelled_basic_statement, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_procedureOrAssignmentStmt_(la.d_type) || FIRST_go_to_statement(la.d_type) ) {
		if( FIRST_procedureOrAssignmentStmt_(la.d_type) ) {
			procedureOrAssignmentStmt_(st);
		} else if( FIRST_go_to_statement(la.d_type) ) {
			go_to_statement(st);
		} else
			invalid("unlabelled_basic_statement");
	}
}

void Parser::procedureOrAssignmentStmt_(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_procedureOrAssignmentStmt_, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "procedureOrAssignmentStmt_") ) addTerminal(st);
	if( la.d_type == Tok_Lbrack || la.d_type == Tok_ColonEq || la.d_type == Tok_Lpar ) {
		if( la.d_type == Tok_Lbrack || la.d_type == Tok_ColonEq ) {
			if( la.d_type == Tok_Lbrack ) {
				if( expect(Tok_Lbrack, false, "procedureOrAssignmentStmt_") ) addTerminal(st);
				subscript_list(st);
				if( expect(Tok_Rbrack, false, "procedureOrAssignmentStmt_") ) addTerminal(st);
			}
			if( expect(Tok_ColonEq, false, "procedureOrAssignmentStmt_") ) addTerminal(st);
			expression(st);
			while( la.d_type == Tok_ColonEq ) {
				if( expect(Tok_ColonEq, false, "procedureOrAssignmentStmt_") ) addTerminal(st);
				expression(st);
			}
		} else if( la.d_type == Tok_Lpar ) {
			if( expect(Tok_Lpar, false, "procedureOrAssignmentStmt_") ) addTerminal(st);
			actual_parameter_list(st);
			if( expect(Tok_Rpar, false, "procedureOrAssignmentStmt_") ) addTerminal(st);
		} else
			invalid("procedureOrAssignmentStmt_");
	}
}

void Parser::go_to_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_go_to_statement, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_GOTO ) {
		if( expect(Tok_GOTO, false, "go_to_statement") ) addTerminal(st);
	} else if( la.d_type == Tok_GO ) {
		if( expect(Tok_GO, false, "go_to_statement") ) addTerminal(st);
		if( expect(Tok_TO, false, "go_to_statement") ) addTerminal(st);
	} else
		invalid("go_to_statement");
	designational_expression(st);
}

void Parser::actual_parameter_list(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_actual_parameter_list, la); st->d_children.append(tmp); st = tmp; }
	actual_parameter(st);
	while( ( ( peek(1).d_type == Tok_Comma || peek(1).d_type == Tok_Rpar && peek(2).d_type == Tok_identifier && peek(3).d_type == Tok_Colon ) )  ) {
		parameter_delimiter(st);
		actual_parameter(st);
	}
}

void Parser::parameter_delimiter(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_parameter_delimiter, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "parameter_delimiter") ) addTerminal(st);
	} else if( la.d_type == Tok_Rpar ) {
		if( expect(Tok_Rpar, false, "parameter_delimiter") ) addTerminal(st);
		letter_string(st);
		if( expect(Tok_Colon, false, "parameter_delimiter") ) addTerminal(st);
		if( expect(Tok_Lpar, false, "parameter_delimiter") ) addTerminal(st);
	} else
		invalid("parameter_delimiter");
}

void Parser::actual_parameter(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_actual_parameter, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_string ) {
		if( expect(Tok_string, false, "actual_parameter") ) addTerminal(st);
	} else if( FIRST_expression(la.d_type) || FIRST_expression(la.d_code) ) {
		expression(st);
	} else
		invalid("actual_parameter");
}

void Parser::conditional_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_conditional_statement, la); st->d_children.append(tmp); st = tmp; }
	if_clause(st);
	while( ( ( peek(1).d_type == Tok_identifier || peek(1).d_type == Tok_unsigned_integer ) && peek(2).d_type == Tok_Colon )  ) {
		label(st);
		if( expect(Tok_Colon, false, "conditional_statement") ) addTerminal(st);
	}
	if( FIRST_unconditional_statement(la.d_type) || la.d_type == Tok_ELSE || la.d_type == Tok_Semi || la.d_type == Tok_Semi || la.d_type == Tok_Semi || la.d_type == Tok_END ) {
		unconditional_statement(st);
		if( la.d_type == Tok_ELSE ) {
			if( expect(Tok_ELSE, false, "conditional_statement") ) addTerminal(st);
			statement(st);
		}
	} else if( FIRST_for_statement(la.d_type) ) {
		for_statement(st);
	} else
		invalid("conditional_statement");
}

void Parser::if_clause(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_if_clause, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_IF, false, "if_clause") ) addTerminal(st);
	Boolean_expression(st);
	if( expect(Tok_THEN, false, "if_clause") ) addTerminal(st);
}

void Parser::for_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_for_statement, la); st->d_children.append(tmp); st = tmp; }
	for_clause(st);
	statement(st);
}

void Parser::for_clause(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_for_clause, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_FOR, false, "for_clause") ) addTerminal(st);
	variable(st);
	if( expect(Tok_ColonEq, false, "for_clause") ) addTerminal(st);
	for_list(st);
	if( expect(Tok_DO, false, "for_clause") ) addTerminal(st);
}

void Parser::for_list(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_for_list, la); st->d_children.append(tmp); st = tmp; }
	for_list_element(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "for_list") ) addTerminal(st);
		for_list_element(st);
	}
}

void Parser::for_list_element(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_for_list_element, la); st->d_children.append(tmp); st = tmp; }
	arithmetic_expression(st);
	if( la.d_type == Tok_STEP || la.d_type == Tok_WHILE ) {
		if( la.d_type == Tok_STEP ) {
			if( expect(Tok_STEP, false, "for_list_element") ) addTerminal(st);
			arithmetic_expression(st);
			if( expect(Tok_UNTIL, false, "for_list_element") ) addTerminal(st);
			arithmetic_expression(st);
		} else if( la.d_type == Tok_WHILE ) {
			if( expect(Tok_WHILE, false, "for_list_element") ) addTerminal(st);
			Boolean_expression(st);
		} else
			invalid("for_list_element");
	}
}

void Parser::expression(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_expression, la); st->d_children.append(tmp); st = tmp; }
	Boolean_expression(st);
}

void Parser::arithmetic_expression(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_arithmetic_expression, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_simple_arithmetic_expression(la.d_type) ) {
		simple_arithmetic_expression(st);
	} else if( FIRST_if_clause(la.d_type) ) {
		if_clause(st);
		simple_arithmetic_expression(st);
		if( expect(Tok_ELSE, false, "arithmetic_expression") ) addTerminal(st);
		arithmetic_expression(st);
	} else
		invalid("arithmetic_expression");
}

void Parser::simple_arithmetic_expression(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_simple_arithmetic_expression, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_adding_operator(la.d_type) ) {
		adding_operator(st);
	}
	term(st);
	while( FIRST_adding_operator(la.d_type) ) {
		adding_operator(st);
		term(st);
	}
}

void Parser::adding_operator(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_adding_operator, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Plus ) {
		if( expect(Tok_Plus, false, "adding_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Minus ) {
		if( expect(Tok_Minus, false, "adding_operator") ) addTerminal(st);
	} else
		invalid("adding_operator");
}

void Parser::term(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_term, la); st->d_children.append(tmp); st = tmp; }
	factor(st);
	while( FIRST_multiplying_operator(la.d_type) || FIRST_multiplying_operator(la.d_code) ) {
		multiplying_operator(st);
		factor(st);
	}
}

void Parser::multiplying_operator(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_multiplying_operator, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Star ) {
		if( expect(Tok_Star, false, "multiplying_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Slash ) {
		if( expect(Tok_Slash, false, "multiplying_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Percent ) {
		if( expect(Tok_Percent, false, "multiplying_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Udiv ) {
		if( expect(Tok_Udiv, false, "multiplying_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Umul ) {
		if( expect(Tok_Umul, false, "multiplying_operator") ) addTerminal(st);
	} else if( la.d_code == Tok_DIV ) {
		if( expect(Tok_DIV, true, "multiplying_operator") ) addTerminal(st);
	} else if( la.d_code == Tok_MOD ) {
		if( expect(Tok_MOD, true, "multiplying_operator") ) addTerminal(st);
	} else
		invalid("multiplying_operator");
}

void Parser::factor(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_factor, la); st->d_children.append(tmp); st = tmp; }
	primary(st);
	while( FIRST_power_sym_(la.d_type) || FIRST_power_sym_(la.d_code) ) {
		power_sym_(st);
		primary(st);
	}
}

void Parser::power_sym_(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_power_sym_, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_POWER ) {
		if( expect(Tok_POWER, true, "power_sym_") ) addTerminal(st);
	} else if( la.d_type == Tok_Uexp ) {
		if( expect(Tok_Uexp, false, "power_sym_") ) addTerminal(st);
	} else if( la.d_type == Tok_Hat ) {
		if( expect(Tok_Hat, false, "power_sym_") ) addTerminal(st);
	} else if( la.d_type == Tok_2Star ) {
		if( expect(Tok_2Star, false, "power_sym_") ) addTerminal(st);
	} else
		invalid("power_sym_");
}

void Parser::primary(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_primary, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_unsigned_number(la.d_type) ) {
		unsigned_number(st);
	} else if( FIRST_variableOrFunction_(la.d_type) ) {
		variableOrFunction_(st);
	} else if( la.d_type == Tok_Lpar ) {
		if( expect(Tok_Lpar, false, "primary") ) addTerminal(st);
		Boolean_expression(st);
		if( expect(Tok_Rpar, false, "primary") ) addTerminal(st);
	} else
		invalid("primary");
}

void Parser::designational_expression(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_designational_expression, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_simple_designational_expression(la.d_type) ) {
		simple_designational_expression(st);
	} else if( FIRST_if_clause(la.d_type) ) {
		if_clause(st);
		simple_designational_expression(st);
		if( expect(Tok_ELSE, false, "designational_expression") ) addTerminal(st);
		designational_expression(st);
	} else
		invalid("designational_expression");
}

void Parser::simple_designational_expression(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_simple_designational_expression, la); st->d_children.append(tmp); st = tmp; }
	primary(st);
}

void Parser::Boolean_expression(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Boolean_expression, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_simple_Boolean(la.d_type) || FIRST_simple_Boolean(la.d_code) ) {
		simple_Boolean(st);
	} else if( FIRST_if_clause(la.d_type) ) {
		if_clause(st);
		simple_Boolean(st);
		if( expect(Tok_ELSE, false, "Boolean_expression") ) addTerminal(st);
		Boolean_expression(st);
	} else
		invalid("Boolean_expression");
}

void Parser::simple_Boolean(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_simple_Boolean, la); st->d_children.append(tmp); st = tmp; }
	implication(st);
	while( FIRST_equiv_sym_(la.d_type) || FIRST_equiv_sym_(la.d_code) ) {
		equiv_sym_(st);
		implication(st);
	}
}

void Parser::equiv_sym_(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_equiv_sym_, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_EQUIV ) {
		if( expect(Tok_EQUIV, true, "equiv_sym_") ) addTerminal(st);
	} else if( la.d_type == Tok_Ueq ) {
		if( expect(Tok_Ueq, false, "equiv_sym_") ) addTerminal(st);
	} else if( la.d_type == Tok_2Eq ) {
		if( expect(Tok_2Eq, false, "equiv_sym_") ) addTerminal(st);
	} else
		invalid("equiv_sym_");
}

void Parser::implication(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_implication, la); st->d_children.append(tmp); st = tmp; }
	Boolean_term(st);
	while( FIRST_impl_sym_(la.d_type) || FIRST_impl_sym_(la.d_code) ) {
		impl_sym_(st);
		Boolean_term(st);
	}
}

void Parser::impl_sym_(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_impl_sym_, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_IMPL ) {
		if( expect(Tok_IMPL, true, "impl_sym_") ) addTerminal(st);
	} else if( la.d_type == Tok_Uimpl ) {
		if( expect(Tok_Uimpl, false, "impl_sym_") ) addTerminal(st);
	} else if( la.d_type == Tok_MinusGt ) {
		if( expect(Tok_MinusGt, false, "impl_sym_") ) addTerminal(st);
	} else
		invalid("impl_sym_");
}

void Parser::Boolean_term(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Boolean_term, la); st->d_children.append(tmp); st = tmp; }
	Boolean_factor(st);
	while( FIRST_or_sym_(la.d_type) || FIRST_or_sym_(la.d_code) ) {
		or_sym_(st);
		Boolean_factor(st);
	}
}

void Parser::or_sym_(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_or_sym_, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_OR ) {
		if( expect(Tok_OR, true, "or_sym_") ) addTerminal(st);
	} else if( la.d_type == Tok_Uor ) {
		if( expect(Tok_Uor, false, "or_sym_") ) addTerminal(st);
	} else if( la.d_type == Tok_Bar ) {
		if( expect(Tok_Bar, false, "or_sym_") ) addTerminal(st);
	} else
		invalid("or_sym_");
}

void Parser::Boolean_factor(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Boolean_factor, la); st->d_children.append(tmp); st = tmp; }
	Boolean_secondary(st);
	while( FIRST_and_sym_(la.d_type) || FIRST_and_sym_(la.d_code) ) {
		and_sym_(st);
		Boolean_secondary(st);
	}
}

void Parser::and_sym_(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_and_sym_, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_AND ) {
		if( expect(Tok_AND, true, "and_sym_") ) addTerminal(st);
	} else if( la.d_type == Tok_Uand ) {
		if( expect(Tok_Uand, false, "and_sym_") ) addTerminal(st);
	} else if( la.d_type == Tok_Amp ) {
		if( expect(Tok_Amp, false, "and_sym_") ) addTerminal(st);
	} else
		invalid("and_sym_");
}

void Parser::Boolean_secondary(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Boolean_secondary, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_not_sym_(la.d_type) || FIRST_not_sym_(la.d_code) ) {
		not_sym_(st);
		Boolean_primary(st);
	} else if( FIRST_Boolean_primary(la.d_type) ) {
		Boolean_primary(st);
	} else
		invalid("Boolean_secondary");
}

void Parser::not_sym_(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_not_sym_, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_NOT ) {
		if( expect(Tok_NOT, true, "not_sym_") ) addTerminal(st);
	} else if( la.d_type == Tok_Unot ) {
		if( expect(Tok_Unot, false, "not_sym_") ) addTerminal(st);
	} else if( la.d_type == Tok_Bang ) {
		if( expect(Tok_Bang, false, "not_sym_") ) addTerminal(st);
	} else
		invalid("not_sym_");
}

void Parser::Boolean_primary(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Boolean_primary, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_logical_value(la.d_type) ) {
		logical_value(st);
	} else if( FIRST_relation(la.d_type) ) {
		relation(st);
	} else
		invalid("Boolean_primary");
}

void Parser::relation(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_relation, la); st->d_children.append(tmp); st = tmp; }
	simple_arithmetic_expression(st);
	if( FIRST_relational_operator(la.d_type) || FIRST_relational_operator(la.d_code) ) {
		relational_operator(st);
		simple_arithmetic_expression(st);
	}
}

void Parser::relational_operator(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_relational_operator, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Lt ) {
		if( expect(Tok_Lt, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Leq ) {
		if( expect(Tok_Leq, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Eq ) {
		if( expect(Tok_Eq, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Geq ) {
		if( expect(Tok_Geq, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Gt ) {
		if( expect(Tok_Gt, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_LtGt ) {
		if( expect(Tok_LtGt, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Uleq ) {
		if( expect(Tok_Uleq, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Ugeq ) {
		if( expect(Tok_Ugeq, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Uneq ) {
		if( expect(Tok_Uneq, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_BangEq ) {
		if( expect(Tok_BangEq, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_HatEq ) {
		if( expect(Tok_HatEq, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_code == Tok_LESS ) {
		if( expect(Tok_LESS, true, "relational_operator") ) addTerminal(st);
	} else if( la.d_code == Tok_NOTGREATER ) {
		if( expect(Tok_NOTGREATER, true, "relational_operator") ) addTerminal(st);
	} else if( la.d_code == Tok_EQUAL ) {
		if( expect(Tok_EQUAL, true, "relational_operator") ) addTerminal(st);
	} else if( la.d_code == Tok_NOTLESS ) {
		if( expect(Tok_NOTLESS, true, "relational_operator") ) addTerminal(st);
	} else if( la.d_code == Tok_GREATER ) {
		if( expect(Tok_GREATER, true, "relational_operator") ) addTerminal(st);
	} else if( la.d_code == Tok_NOTEQUAL ) {
		if( expect(Tok_NOTEQUAL, true, "relational_operator") ) addTerminal(st);
	} else
		invalid("relational_operator");
}

void Parser::variableOrFunction_(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_variableOrFunction_, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "variableOrFunction_") ) addTerminal(st);
	if( la.d_type == Tok_Lbrack || la.d_type == Tok_Lpar ) {
		if( la.d_type == Tok_Lbrack ) {
			if( expect(Tok_Lbrack, false, "variableOrFunction_") ) addTerminal(st);
			subscript_list(st);
			if( expect(Tok_Rbrack, false, "variableOrFunction_") ) addTerminal(st);
		} else if( la.d_type == Tok_Lpar ) {
			if( expect(Tok_Lpar, false, "variableOrFunction_") ) addTerminal(st);
			actual_parameter_list(st);
			if( expect(Tok_Rpar, false, "variableOrFunction_") ) addTerminal(st);
		} else
			invalid("variableOrFunction_");
	}
}

void Parser::variable(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_variable, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "variable") ) addTerminal(st);
	if( la.d_type == Tok_Lbrack ) {
		if( expect(Tok_Lbrack, false, "variable") ) addTerminal(st);
		subscript_list(st);
		if( expect(Tok_Rbrack, false, "variable") ) addTerminal(st);
	}
}

void Parser::simple_variable(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_simple_variable, la); st->d_children.append(tmp); st = tmp; }
	variable_identifier(st);
}

void Parser::variable_identifier(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_variable_identifier, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "variable_identifier") ) addTerminal(st);
}

void Parser::subscript_list(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_subscript_list, la); st->d_children.append(tmp); st = tmp; }
	subscript_expression(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "subscript_list") ) addTerminal(st);
		subscript_expression(st);
	}
}

void Parser::subscript_expression(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_subscript_expression, la); st->d_children.append(tmp); st = tmp; }
	arithmetic_expression(st);
}

void Parser::unsigned_number(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_unsigned_number, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_unsigned_integer ) {
		if( expect(Tok_unsigned_integer, false, "unsigned_number") ) addTerminal(st);
	} else if( la.d_type == Tok_decimal_number ) {
		if( expect(Tok_decimal_number, false, "unsigned_number") ) addTerminal(st);
	} else
		invalid("unsigned_number");
}

void Parser::letter_string(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_letter_string, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "letter_string") ) addTerminal(st);
}

void Parser::logical_value(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_logical_value, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_TRUE ) {
		if( expect(Tok_TRUE, false, "logical_value") ) addTerminal(st);
	} else if( la.d_type == Tok_FALSE ) {
		if( expect(Tok_FALSE, false, "logical_value") ) addTerminal(st);
	} else
		invalid("logical_value");
}

