

// This file was automatically generated by Coco/R; don't modify it.
#if !defined(Alg_COCO_PARSER_H__)
#define Alg_COCO_PARSER_H__

#include <QStack>
#include <Algol/AlgSynTree.h>


#define PARSER_NS Alg
#include <Algol/AlgLexer.h>

namespace Alg {



class Parser {
private:
	enum {
		_EOF=0,
		_T_Literals_=1,
		_T_Bang=2,
		_T_BangEq=3,
		_T_Percent=4,
		_T_Amp=5,
		_T_Lpar=6,
		_T_Rpar=7,
		_T_Star=8,
		_T_2Star=9,
		_T_Plus=10,
		_T_Comma=11,
		_T_Minus=12,
		_T_MinusGt=13,
		_T_Slash=14,
		_T_Colon=15,
		_T_ColonEq=16,
		_T_Semi=17,
		_T_Lt=18,
		_T_Leq=19,
		_T_LtGt=20,
		_T_Eq=21,
		_T_2Eq=22,
		_T_Gt=23,
		_T_Geq=24,
		_T_Lbrack=25,
		_T_Rbrack=26,
		_T_Hat=27,
		_T_HatEq=28,
		_T_Bar=29,
		_T_Unot=30,
		_T_Umul=31,
		_T_Udiv=32,
		_T_Uexp=33,
		_T_Uand=34,
		_T_Uor=35,
		_T_Uneq=36,
		_T_Ueq=37,
		_T_Uleq=38,
		_T_Ugeq=39,
		_T_Uimpl=40,
		_T_Keywords_=41,
		_T_AND=42,
		_T_ARRAY=43,
		_T_BEGIN=44,
		_T_BOOLEAN=45,
		_T_COMMENT=46,
		_T_DIV=47,
		_T_DO=48,
		_T_ELSE=49,
		_T_END=50,
		_T_EQUAL=51,
		_T_EQUIV=52,
		_T_FALSE=53,
		_T_FOR=54,
		_T_GO=55,
		_T_GOTO=56,
		_T_GREATER=57,
		_T_IF=58,
		_T_IMPL=59,
		_T_INTEGER=60,
		_T_LABEL=61,
		_T_LESS=62,
		_T_MOD=63,
		_T_NOT=64,
		_T_NOTEQUAL=65,
		_T_NOTGREATER=66,
		_T_NOTLESS=67,
		_T_OR=68,
		_T_OWN=69,
		_T_POWER=70,
		_T_PROCEDURE=71,
		_T_REAL=72,
		_T_STEP=73,
		_T_STRING=74,
		_T_SWITCH=75,
		_T_THEN=76,
		_T_TO=77,
		_T_TRUE=78,
		_T_UNTIL=79,
		_T_VALUE=80,
		_T_WHILE=81,
		_T_Specials_=82,
		_T_decimal_number=83,
		_T_unsigned_integer=84,
		_T_string=85,
		_T_identifier=86,
		_T_basic_symbol=87,
		_T_Comment=88,
		_T_Eof=89,
		_T_MaxToken_=90
	};
	int maxT;

	int errDist;
	int minErrDist;

	void SynErr(int n, const char* ctx = 0);
	void Get();
	void Expect(int n, const char* ctx = 0);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);
    void SynErr(const QString& sourcePath, int line, int col, int n, PARSER_NS::Errors* err, const char* ctx, const QString& = QString() );

public:
	PARSER_NS::Lexer *scanner;
	PARSER_NS::Errors  *errors;

	PARSER_NS::Token d_cur;
	PARSER_NS::Token d_next;
	QList<PARSER_NS::Token> d_comments;
	struct TokDummy
	{
		int kind;
	};
	TokDummy d_dummy;
	TokDummy *la;			// lookahead token
	
	int peek( quint8 la = 1 );

    void RunParser()
    {
        d_stack.push(&d_root);
        Parse();
        d_stack.pop();
    }
        
Alg::SynTree d_root;
	QStack<Alg::SynTree*> d_stack;
	void addTerminal() {
		Alg::SynTree* n = new Alg::SynTree( d_cur ); d_stack.top()->d_children.append(n);
	}



	Parser(PARSER_NS::Lexer *scanner,PARSER_NS::Errors*);
	~Parser();
	void SemErr(const char* msg);

	void program();
	void label();
	void compoundBlock_();
	void declaration();
	void compound_tail();
	void statement();
	void switch_declaration();
	void procedure_declaration();
	void array_declaration();
	void type_declaration();
	void local_or_own_type();
	void type_list();
	void type();
	void simple_variable();
	void array_list();
	void array_segment();
	void bound_pair_list();
	void bound_pair();
	void lower_bound();
	void upper_bound();
	void arithmetic_expression();
	void switch_identifier();
	void switch_list();
	void designational_expression();
	void procedure_heading();
	void procedure_body();
	void procedure_identifier();
	void formal_parameter_part();
	void value_part();
	void specification_part();
	void formal_parameter_list();
	void formal_parameter();
	void parameter_delimiter();
	void identifier_list();
	void specifier();
	void unconditional_statement();
	void conditional_statement();
	void for_statement();
	void basic_statement();
	void unlabelled_basic_statement();
	void procedureOrAssignmentStmt_();
	void go_to_statement();
	void subscript_list();
	void expression();
	void actual_parameter_list();
	void actual_parameter();
	void letter_string();
	void if_clause();
	void Boolean_expression();
	void for_clause();
	void variable();
	void for_list();
	void for_list_element();
	void simple_arithmetic_expression();
	void adding_operator();
	void term();
	void factor();
	void multiplying_operator();
	void primary();
	void power_sym_();
	void unsigned_number();
	void variableOrFunction_();
	void simple_designational_expression();
	void simple_Boolean();
	void implication();
	void equiv_sym_();
	void Boolean_term();
	void impl_sym_();
	void Boolean_factor();
	void or_sym_();
	void Boolean_secondary();
	void and_sym_();
	void Boolean_primary();
	void not_sym_();
	void logical_value();
	void relation();
	void relational_operator();
	void variable_identifier();
	void subscript_expression();

	void Parse();

}; // end Parser

} // namespace


#endif

