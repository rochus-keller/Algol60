// This file was automatically generated by EbnfStudio; don't modify it!
#include "AlgSynTree.h"
using namespace Alg;

SynTree::SynTree(quint16 r, const Token& t ):d_tok(r){
	d_tok.d_lineNr = t.d_lineNr;
	d_tok.d_colNr = t.d_colNr;
	d_tok.d_sourcePath = t.d_sourcePath;
}

const char* SynTree::rToStr( quint16 r ) {
	switch(r) {
		case R_Boolean_expression: return "Boolean_expression";
		case R_Boolean_factor: return "Boolean_factor";
		case R_Boolean_primary: return "Boolean_primary";
		case R_Boolean_secondary: return "Boolean_secondary";
		case R_Boolean_term: return "Boolean_term";
		case R_actual_parameter: return "actual_parameter";
		case R_actual_parameter_list: return "actual_parameter_list";
		case R_adding_operator: return "adding_operator";
		case R_and_sym_: return "and_sym_";
		case R_arithmetic_expression: return "arithmetic_expression";
		case R_array_declaration: return "array_declaration";
		case R_array_list: return "array_list";
		case R_array_segment: return "array_segment";
		case R_basic_statement: return "basic_statement";
		case R_bound_pair: return "bound_pair";
		case R_bound_pair_list: return "bound_pair_list";
		case R_comment_: return "comment";
		case R_compoundBlock_: return "compoundBlock_";
		case R_compound_tail: return "compound_tail";
		case R_conditional_statement: return "conditional_statement";
		case R_declaration: return "declaration";
		case R_designational_expression: return "designational_expression";
		case R_equiv_sym_: return "equiv_sym_";
		case R_expression: return "expression";
		case R_factor: return "factor";
		case R_for_clause: return "for_clause";
		case R_for_list: return "for_list";
		case R_for_list_element: return "for_list_element";
		case R_for_statement: return "for_statement";
		case R_formal_parameter: return "formal_parameter";
		case R_formal_parameter_list: return "formal_parameter_list";
		case R_formal_parameter_part: return "formal_parameter_part";
		case R_go_to_statement: return "go_to_statement";
		case R_identifier_list: return "identifier_list";
		case R_if_clause: return "if_clause";
		case R_impl_sym_: return "impl_sym_";
		case R_implication: return "implication";
		case R_label: return "label";
		case R_letter_string: return "letter_string";
		case R_local_or_own_type: return "local_or_own_type";
		case R_logical_value: return "logical_value";
		case R_lower_bound: return "lower_bound";
		case R_multiplying_operator: return "multiplying_operator";
		case R_not_sym_: return "not_sym_";
		case R_or_sym_: return "or_sym_";
		case R_parameter_delimiter: return "parameter_delimiter";
		case R_power_sym_: return "power_sym_";
		case R_primary: return "primary";
		case R_procedureOrAssignmentStmt_: return "procedureOrAssignmentStmt_";
		case R_procedure_body: return "procedure_body";
		case R_procedure_declaration: return "procedure_declaration";
		case R_procedure_heading: return "procedure_heading";
		case R_procedure_identifier: return "procedure_identifier";
		case R_program: return "program";
		case R_relation: return "relation";
		case R_relational_operator: return "relational_operator";
		case R_simple_Boolean: return "simple_Boolean";
		case R_simple_arithmetic_expression: return "simple_arithmetic_expression";
		case R_simple_designational_expression: return "simple_designational_expression";
		case R_simple_variable: return "simple_variable";
		case R_specification_part: return "specification_part";
		case R_specifier: return "specifier";
		case R_statement: return "statement";
		case R_subscript_expression: return "subscript_expression";
		case R_subscript_list: return "subscript_list";
		case R_switch_declaration: return "switch_declaration";
		case R_switch_identifier: return "switch_identifier";
		case R_switch_list: return "switch_list";
		case R_term: return "term";
		case R_type: return "type";
		case R_type_declaration: return "type_declaration";
		case R_type_list: return "type_list";
		case R_unconditional_statement: return "unconditional_statement";
		case R_unlabelled_basic_statement: return "unlabelled_basic_statement";
		case R_unsigned_number: return "unsigned_number";
		case R_upper_bound: return "upper_bound";
		case R_value_part: return "value_part";
		case R_variable: return "variable";
		case R_variableOrFunction_: return "variableOrFunction_";
		case R_variable_identifier: return "variable_identifier";
	default: if(r<R_First) return tokenTypeName(r); else return "";
}
}
